package dev.project.modules.exploit;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import dev.project.configs.BacktrackConfig;
import dev.project.modules.Category;
import dev.project.modules.Module;
import dev.project.util.PlayerSnapshot;
import java.util.ArrayDeque;
import java.util.Comparator;
import java.util.Deque;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderContext;
import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;
import net.minecraft.client.MinecraftClient;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;

public final class Backtrack extends Module {
    public static final Backtrack INSTANCE = new Backtrack();

    private static boolean hooksRegistered;
    private final BacktrackConfig config = new BacktrackConfig();
    private final Map<UUID, Deque<PlayerSnapshot>> snapshotHistory = new ConcurrentHashMap<>();
    private int worldTick;

    private Backtrack() {
        super("Backtrack", Category.EXPLOIT, new BacktrackConfig());
    }

    @Override
    public void onEnable() {
        if (hooksRegistered) {
            return;
        }
        hooksRegistered = true;
        ClientTickEvents.END_CLIENT_TICK.register(this::onClientTickEnd);
        WorldRenderEvents.AFTER_ENTITIES.register(this::onRenderGhosts);
    }

    @Override
    public void onDisable() {
        snapshotHistory.clear();
    }

    @Override
    public void onTick(MinecraftClient client) {
        if (!isEnabled() || client.player == null || client.world == null) {
            return;
        }
        worldTick++;

        for (PlayerEntity player : client.world.getPlayers()) {
            if (player == client.player) {
                continue;
            }
            if (config.ignoreInvisible && player.isInvisible()) {
                continue;
            }

            Deque<PlayerSnapshot> snapshots = snapshotHistory.computeIfAbsent(player.getUuid(), ignored -> new ArrayDeque<>());
            snapshots.addLast(new PlayerSnapshot(player.getUuid(), player.getPos(), worldTick, player.getHealth(), player.isAlive()));

            while (snapshots.size() > config.historyTicks) {
                snapshots.removeFirst();
            }
        }
    }

    private void onClientTickEnd(MinecraftClient client) {
        if (!isEnabled() || !config.pauseOnLag) {
            return;
        }
        if (FakeLag.INSTANCE.isEnabled()) {
            return;
        }

        snapshotHistory.values().removeIf(Deque::isEmpty);
    }

    private void onRenderGhosts(WorldRenderContext context) {
        if (!isEnabled() || !config.visualize) {
            return;
        }

        MinecraftClient client = MinecraftClient.getInstance();
        if (client.world == null || client.player == null) {
            return;
        }

        for (Deque<PlayerSnapshot> history : snapshotHistory.values()) {
            PlayerSnapshot snapshot = history.peekLast();
            if (snapshot == null) {
                continue;
            }
            PlayerEntity player = client.world.getPlayerByUuid(snapshot.playerId());
            if (player == null) {
                continue;
            }
            player.setGlowing(true);
        }
    }

    public Entity resolveAttackTarget(Entity originalTarget) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (!isEnabled() || client.world == null || client.player == null || !(originalTarget instanceof PlayerEntity playerTarget)) {
            return originalTarget;
        }
        if (config.pauseOnLag && FakeLag.INSTANCE.isEnabled()) {
            return originalTarget;
        }

        Deque<PlayerSnapshot> history = snapshotHistory.get(playerTarget.getUuid());
        if (history == null || history.isEmpty()) {
            return originalTarget;
        }

        PlayerSnapshot selected = selectSnapshot(client.player.getPos(), history);
        if (selected == null || selected.position().distanceTo(client.player.getPos()) > config.maxDistance) {
            return originalTarget;
        }

        return client.world.getPlayerByUuid(selected.playerId()) == null ? originalTarget : client.world.getPlayerByUuid(selected.playerId());
    }

    private PlayerSnapshot selectSnapshot(Vec3d selfPosition, Deque<PlayerSnapshot> history) {
        return switch (config.attackMode) {
            case CLOSEST -> history.stream().min(Comparator.comparingDouble(snapshot -> snapshot.position().distanceTo(selfPosition))).orElse(null);
            case FURTHEST -> history.stream().max(Comparator.comparingDouble(snapshot -> snapshot.position().distanceTo(selfPosition))).orElse(null);
            case OLDEST -> history.peekFirst();
            case NEWEST -> history.peekLast();
        };
    }

    @Override
    protected void applyConfig(JsonObject cfg) {
        BacktrackConfig loaded = new Gson().fromJson(cfg, BacktrackConfig.class);
        config.historyTicks = loaded.historyTicks;
        config.visualize = loaded.visualize;
        config.visualizeColor = loaded.visualizeColor;
        config.attackMode = loaded.attackMode;
        config.pauseOnLag = loaded.pauseOnLag;
        config.ignoreInvisible = loaded.ignoreInvisible;
        config.maxDistance = loaded.maxDistance;
        config.validate();
    }
}
