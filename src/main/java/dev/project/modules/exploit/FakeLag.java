package dev.project.modules.exploit;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import dev.project.configs.FakeLagConfig;
import dev.project.modules.Category;
import dev.project.modules.Module;
import java.util.Comparator;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
import net.fabricmc.fabric.api.client.networking.v1.ClientSendPacketEvents;
import net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback;
import net.minecraft.client.MinecraftClient;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;

public final class FakeLag extends Module {
    public static final FakeLag INSTANCE = new FakeLag();

    private static boolean hooksRegistered;
    private final FakeLagConfig config = new FakeLagConfig();
    private final Queue<DelayedPacket> delayedPackets = new ConcurrentLinkedQueue<>();
    private int clientTick;

    private FakeLag() {
        super("FakeLag", Category.EXPLOIT, new FakeLagConfig());
    }

    @Override
    public void onEnable() {
        if (hooksRegistered) {
            return;
        }
        hooksRegistered = true;

        ClientSendPacketEvents.ALLOW.register((packet, packetSender) -> {
            if (!isEnabled()) {
                return true;
            }
            if (!(packet instanceof PlayerMoveC2SPacket)) {
                return true;
            }
            if (!shouldLagNow(MinecraftClient.getInstance())) {
                return true;
            }

            delayedPackets.offer(new DelayedPacket(packet, clientTick + config.delayTicks, clientTick));
            if (config.mode == FakeLagConfig.Mode.BLINK || config.consumePackets) {
                return false;
            }
            return false;
        });

        ClientTickEvents.END_CLIENT_TICK.register(this::onEndTick);

        HudRenderCallback.EVENT.register((drawContext, tickCounter) -> {
            if (!isEnabled() || !config.visualIndicator) {
                return;
            }
            MinecraftClient client = MinecraftClient.getInstance();
            if (client.textRenderer == null) {
                return;
            }
            drawContext.drawTextWithShadow(client.textRenderer, "FakeLag [" + config.mode + "]" + " queue=" + delayedPackets.size(), 6, 6, 0x00FFAA);
        });
    }

    @Override
    public void onDisable() {
        if (config.flushOnDisable) {
            flushAll(MinecraftClient.getInstance());
        }
        delayedPackets.clear();
    }

    @Override
    public void onTick(MinecraftClient client) {
        if (!isEnabled()) {
            return;
        }
        clientTick++;

        if (config.cancelOnDamage && client.player != null && client.player.hurtTime > 0) {
            flushAll(client);
            toggle();
            return;
        }

        if (bufferAgeExceeded()) {
            flushAll(client);
        }
    }

    private void onEndTick(MinecraftClient client) {
        if (!isEnabled() || client.getNetworkHandler() == null) {
            return;
        }
        while (!delayedPackets.isEmpty()) {
            DelayedPacket delayed = delayedPackets.peek();
            if (delayed == null || delayed.releaseTick() > clientTick) {
                break;
            }
            delayedPackets.poll();
            client.getNetworkHandler().sendPacket(delayed.packet());
        }
    }

    private boolean shouldLagNow(MinecraftClient client) {
        if (client.player == null || client.world == null) {
            return false;
        }
        if (config.mode == FakeLagConfig.Mode.BLINK || config.mode == FakeLagConfig.Mode.STATIC) {
            return true;
        }

        PlayerEntity nearest = client.world.getPlayers().stream()
            .filter(player -> player != client.player)
            .min(Comparator.comparingDouble(player -> player.squaredDistanceTo(client.player)))
            .orElse(null);

        if (nearest == null) {
            return false;
        }

        if (config.onlyWhenTargeted && !(client.crosshairTarget instanceof net.minecraft.util.hit.EntityHitResult hit && hit.getEntity() == nearest)) {
            return false;
        }

        return nearest.distanceTo(client.player) <= config.triggerRange;
    }

    private boolean bufferAgeExceeded() {
        DelayedPacket oldest = delayedPackets.peek();
        return oldest != null && clientTick - oldest.createdTick() >= config.maxBufferTime;
    }

    private void flushAll(MinecraftClient client) {
        if (client.getNetworkHandler() == null) {
            return;
        }
        while (!delayedPackets.isEmpty()) {
            DelayedPacket delayed = delayedPackets.poll();
            if (delayed != null) {
                client.getNetworkHandler().sendPacket(delayed.packet());
            }
        }
    }

    @Override
    protected void applyConfig(JsonObject cfg) {
        FakeLagConfig loaded = new Gson().fromJson(cfg, FakeLagConfig.class);
        config.mode = loaded.mode;
        config.delayTicks = loaded.delayTicks;
        config.triggerRange = loaded.triggerRange;
        config.onlyWhenTargeted = loaded.onlyWhenTargeted;
        config.visualIndicator = loaded.visualIndicator;
        config.consumePackets = loaded.consumePackets;
        config.cancelOnDamage = loaded.cancelOnDamage;
        config.flushOnDisable = loaded.flushOnDisable;
        config.maxBufferTime = loaded.maxBufferTime;
        config.validate();
    }

    private record DelayedPacket(Packet<?> packet, int releaseTick, int createdTick) {}
}
